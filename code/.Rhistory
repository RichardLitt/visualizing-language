as.factor(x)
factor(x)
factor(x,levels=1:3)
factor(x,levels=as.character(1:3))
factor(x,labels=1:3)
?is.element
levels(as.factor(c(4,4,4)))
length(levels(as.factor(c(4,4,4))))
best.features
best.features[1]
best.features[2]
best.features[-5]
for(i in 1:length(best.features)) {#
	feature.row = data.subset[best.features[i],]#
	if(length(levels(as.factor(feature.row)))==1) {#
		new.best.features = best.features[-i]#
	}#
}
new.best.features
feature.row
for(i in 1:length(best.features)) {#
	feature.row = data.subset[names(best.features[i]),]#
	if(length(levels(as.factor(feature.row)))==1) {#
		new.best.features = best.features[-i]#
	}#
}
names(best.features)
head(rownames(data.subset))
	data.subset = geo_data[which(geo_data$center.language==language),]
	data.subset = t(data.subset[,11:ncol(data.subset)])
best.features = sorted.features[1:15]
for(i in 1:length(best.features)) {#
	feature.row = data.subset[names(best.features[i]),]#
	if(length(levels(as.factor(feature.row)))==1) {#
		new.best.features = best.features[-i]#
	}#
}
new.best.features
length(new.best.features)
length(best.features)
data.subset[names(best.features[1]),]
names(best.features[1])
length(levels(as.factor(data.subset[names(best.features[1]),])))
length(levels(as.factor(data.subset[names(best.features[2]),])))
length(levels(as.factor(data.subset[names(best.features[3]),])))
length(levels(as.factor(data.subset[names(best.features[4]),])))
length(levels(as.factor(data.subset[names(best.features[5]),])))
length(levels(as.factor(data.subset[names(best.features[6]),])))
length(levels(as.factor(data.subset[names(best.features[7]),])))
length(levels(as.factor(data.subset[names(best.features[8]),])))
length(levels(as.factor(data.subset[names(best.features[9]),])))
length(levels(as.factor(data.subset[names(best.features[10]),])))
length(levels(as.factor(data.subset[names(best.features[11]),])))
length(levels(as.factor(data.subset[names(best.features[12]),])))
length(levels(as.factor(data.subset[names(best.features[13]),])))
length(levels(as.factor(data.subset[names(best.features[14]),])))
length(levels(as.factor(data.subset[names(best.features[15]),])))
new.best.feature = best.features
for(i in 1:length(best.features)) {#
	feature.row = data.subset[names(best.features[i]),]#
	if(length(levels(as.factor(feature.row)))==1) {#
		new.best.features = new.best.features[-i]#
	}#
}
new.best.features
sapply(1:5,function(x) if(x%2==0) {x} else {next()})
sapply(1:5,function(x) if(x%2==0) {x} else {next})
sapply(1:5,function(x) if(x%2==0) {x})
sapply(c(1,2,3,4,5),function(x) if(x%2==0) {x})
sapply(1:5,function(x) if(x%%2==0) {x} else {next()})
sapply(1:5,function(x) if(x%%2==0) {x} else {skip})
sapply(1:5,function(x) if(x%%2==0) {x} else {skip()})
sapply(1:5,function(x) if(x%%2==0) {x} else {NA})
complete.cases(sapply(1:5,function(x) if(x%%2==0) {x} else {NA})()
)
complete.cases(sapply(1:5,function(x) if(x%%2==0) {x} else {NA}))
sapply(1:5,function(x) if(x%%2==0) {x} else {})
sapply(1:5,function(x) if(x%%2==0) {x})
new.best.feature = best.features#
for(i in 1:length(best.features)) {#
	feature.row = data.subset[names(best.features[i]),]#
	if(length(levels(as.factor(feature.row)))==1) {#
		new.best.features = new.best.features[-i]#
	}#
}
length(new.best.feature)
new.best.feature
new.best.features = best.features#
for(i in 1:length(best.features)) {#
	feature.row = data.subset[names(best.features[i]),]#
	if(length(levels(as.factor(feature.row)))==1) {#
		new.best.features = new.best.features[-i]#
	}#
}
new.best.features
rm(new.best.feature)
length(new.best.features)
15-length(new.best.features)
15+15-length(new.best.features)
15+length(new.best.features)
15+15-length(new.best.features)
15+(15-length(new.best.features)
)
15+(15-length(new.best.features))
15:15+(15-length(new.best.features))
15:(15+(15-length(new.best.features)))
16:(15+(15-length(new.best.features)))
16:15
sorted.features[0]
c(5,sorted.features[0])
c(5)
difference = 15-length(new.best.features)
if(difference > 0) {#
	best.features = c(new.best.features,sorted.features[15+])#
}
difference = 15-length(new.best.features)#
if(difference > 0) {#
	best.features = c(new.best.features,sorted.features[16:(15+difference)])#
}
best.features
length(best.features)
NA == 0
Inf == 0
best.features = sorted.features[1:15]
difference = Inf#
while(difference!=0) {#
	new.best.features = best.features#
	for(i in 1:length(best.features)) {#
		feature.row = data.subset[names(best.features[i]),]#
		if(length(levels(as.factor(feature.row)))==1) {#
			new.best.features = new.best.features[-i]#
		}#
	}#
#
	difference = 15-length(new.best.features)#
	if(difference > 0) {#
		best.features = c(new.best.features,sorted.features[16:(15+difference)])#
	}#
}
best.features
nlevels = rep(NA,15)
while(difference!=0) {#
	new.best.features = best.features#
	for(i in 1:length(best.features)) {#
		feature.row = data.subset[names(best.features[i]),]#
		nlevels[i] = length(levels(as.factor(feature.row)))#
		if(nlevels[i]==1) {#
			new.best.features = new.best.features[-i]#
		}#
	}#
#
	difference = 15-length(new.best.features)#
	if(difference > 0) {#
		best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
		index = index+difference#
	}#
}
nlevels
best.features
length(levels(as.factor(feature.row)))
nlevels
nlevels[i]
nlevels[i] = length(levels(as.factor(feature.row)))
nlevels
difference = Inf#
index = 15#
nlevels = rep(NA,15)#
while(difference!=0) {#
	new.best.features = best.features#
	for(i in 1:length(best.features)) {#
		feature.row = data.subset[names(best.features[i]),]#
		nlevels[i] = length(levels(as.factor(feature.row)))#
		if(nlevels[i]==1) {#
			new.best.features = new.best.features[-i]#
		}#
	}#
#
	difference = 15-length(new.best.features)#
	if(difference > 0) {#
		best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
		index = index+difference#
	}#
}
nlevels
data.subset["100",]
difference = Inf#
index = 15#
while(difference!=0) {#
	new.best.features = best.features#
	for(i in 1:length(best.features)) {#
		feature.row = data.subset[names(best.features[i]),]#
		nlevel = length(levels(as.factor(feature.row)))#
		if(nlevel==1) {#
			new.best.features = new.best.features[-i]#
		} else {#
			data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevel))#
		}#
	}#
#
	difference = 15-length(new.best.features)#
	if(difference > 0) {#
		best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
		index = index+difference#
	}#
}
data.subset["100",]
data.subset["175",]
data.subset["171",]
nlevels = rep(NA,15)#
difference = Inf#
index = 15#
while(difference!=0) {#
	new.best.features = best.features#
	for(i in 1:length(best.features)) {#
		feature.row = data.subset[names(best.features[i]),]#
		nlevels[i] = length(levels(as.factor(feature.row)))#
		if(nlevels[i]==1) {#
			new.best.features = new.best.features[-i]#
		} else {#
			data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
		}#
	}#
#
	difference = 15-length(new.best.features)#
	if(difference > 0) {#
		best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
		index = index+difference#
	}#
}#
#
#
max(nlevels)
best.features = sorted.features[1:15]#
#
nlevels = rep(NA,15)#
difference = Inf#
index = 15#
while(difference!=0) {#
	new.best.features = best.features#
	for(i in 1:length(best.features)) {#
		feature.row = data.subset[names(best.features[i]),]#
		nlevels[i] = length(levels(as.factor(feature.row)))#
		if(nlevels[i]==1) {#
			new.best.features = new.best.features[-i]#
		} else {#
			data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
		}#
	}#
#
	difference = 15-length(new.best.features)#
	if(difference > 0) {#
		best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
		index = index+difference#
	}#
}#
#
#
max(nlevels)
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(names(best.features),shift=10)
data.subset = data.subset[(as.numeric(names(best.features))),]
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])
	rownames(data.subset) = get.feature(names(best.features),shift=10)
names(data.subset)
colnames(data.subset)
	data.subset = geo_data[which(geo_data$center.language==language),]
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})
data.subset = t(data.subset[,11:ncol(data.subset)])
	best.features = sorted.features[1:15]
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[names(best.features[i]),]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			} else {#
				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
			index = index+difference#
		}#
	}
	data.subset = data.subset[(as.numeric(names(best.features))),]
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])
	rownames(data.subset) = get.feature(names(best.features),shift=10)
	heatmap(data.subset,Rowv=NA,Colv=NA,col=brewer.pal(max(nlevels),"Set1"),ColSideColors=colcolors)
data.subset
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = sorted.features[1:15]#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[names(best.features[i]),]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			}# else {#
#				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
			index = index+difference#
		}#
	}#
#
# Get rid of all of the other features#
	data.subset = data.subset[(as.numeric(names(best.features))),]#
#
#	data.subset = geo_data[which(geo_data$center.language==language),c(1:10,(as.numeric(names(best.features))))]#
#
# Set the names of the columns and rows#
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(names(best.features),shift=10)
	heatmap(data.subset,Rowv=NA,Colv=NA,col=brewer.pal(max(nlevels),"Set1"),ColSideColors=colcolors)
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = sorted.features[1:15]#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[names(best.features[i]),]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			}# else {#
#				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			#}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
			index = index+difference#
		}#
	}#
#
# Get rid of all of the other features#
	data.subset = data.subset[(as.numeric(names(best.features))),]#
#
#	data.subset = geo_data[which(geo_data$center.language==language),c(1:10,(as.numeric(names(best.features))))]#
#
# Set the names of the columns and rows#
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(names(best.features),shift=10)
	heatmap(data.subset,Rowv=NA,Colv=NA,col=brewer.pal(max(nlevels),"Set1"),ColSideColors=colcolors)
data.subset
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = sorted.features[1:15]#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
#	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[names(best.features[i]),]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			}# else {#
#				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			#}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
			index = index+difference#
		}#
#	}#
#
# Get rid of all of the other features#
	data.subset = data.subset[(as.numeric(names(best.features))),]#
#
#	data.subset = geo_data[which(geo_data$center.language==language),c(1:10,(as.numeric(names(best.features))))]#
#
# Set the names of the columns and rows#
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(names(best.features),shift=10)
data.subset
	data.subset = geo_data[which(geo_data$center.language==language),]
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})
	data.subset = t(data.subset[,11:ncol(data.subset)])
	best.features = sorted.features[1:15]
best.features
	best.features = names(sorted.features[1:15])
best.features
	best.features = names(sorted.features[1:15])
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
#	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			}# else {#
#				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			#}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,sorted.features[(index+1):(index+difference)])#
			index = index+difference#
		}
best.features
	best.features = names(sorted.features[1:15])#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
#	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			}# else {#
#				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			#}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,names(sorted.features[(index+1):(index+difference)]))#
			index = index+difference#
		}#
#	}
best.features
get.feature(best.features,shift=10)
data.subset[,1:10]
data.subset[1:5,2]
data.subset[2,1:5]
data.subset[20,1:5]
data.subset["20",1:5]
data.subset["100",1:5]
names(sorted.features)
sort(names(sorted.features))
min(as.numeric(names(sorted.features)))
	data.subset = data.subset[(best.features),]
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(best.features),shift=10)
	rownames(data.subset) = get.feature(best.features,shift=10)
	heatmap(data.subset,Rowv=NA,Colv=NA,col=brewer.pal(max(nlevels),"Set1"),ColSideColors=colcolors)
data.subset
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = names(sorted.features[1:15])#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
#	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			} else {#
				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,names(sorted.features[(index+1):(index+difference)]))#
			index = index+difference#
		}#
#	}#
#
# Get rid of all of the other features#
	data.subset = data.subset[(best.features),]#
#
#	data.subset = geo_data[which(geo_data$center.language==language),c(1:10,(as.numeric(names(best.features))))]#
#
# Set the names of the columns and rows#
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(best.features,shift=10)
i
nlevels
factor(data.subset[names(best.features[i]),],labels=1:nlevels[i])
factor(data.subset[names(best.features[i]),],labels=1:2)
table(data.subset[names(best.features[i]),])
data.subset[names(best.features[i]),]
best.features
best.features[2]
data.subset["171",]
rownames(data.subset)
dim(data.subset)
	data.subset = geo_data[which(geo_data$center.language==language),]
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})
	data.subset = t(data.subset[,11:ncol(data.subset)])
	best.features = names(sorted.features[1:15])
nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
#	while(difference!=0) {#
		new.best.features = best.features
for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			} else {#
				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			}#
		}
i
best.features
rownames(data.subset)
dim(dats.subset)
dim(data.subset)
data.subset["100",]
factor(data.subset["100",])
factor(data.subset["100",],labels=1:2)
i
factor(data.subset["171",],labels=1:2)
(data.subset["171",])
nlevels
feature.row
length(levels(as.factor(feature.row)))
1:1
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = names(sorted.features[1:15])#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
#	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			} else {#
				data.subset[names(best.features[i]),] = as.numeric(factor(data.subset[names(best.features[i]),],labels=1:nlevels[i]))#
			}#
		}
nlevels[i]
factor(data.subset[names(best.features[i]), ], labels = 1:nlevels[i])
data.subset[names(best.features[i]), ]
best.features[i]
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = names(sorted.features[1:15])#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
#	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			} else {#
				data.subset[best.features[i],] = as.numeric(factor(data.subset[best.features[i],],labels=1:nlevels[i]))#
			}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,names(sorted.features[(index+1):(index+difference)]))#
			index = index+difference#
		}#
#	}#
#
# Get rid of all of the other features#
	data.subset = data.subset[(best.features),]#
#
#	data.subset = geo_data[which(geo_data$center.language==language),c(1:10,(as.numeric(names(best.features))))]#
#
# Set the names of the columns and rows#
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(best.features,shift=10)
	heatmap(data.subset,Rowv=NA,Colv=NA,col=brewer.pal(max(nlevels),"Set1"),ColSideColors=colcolors)
data.subset
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = names(sorted.features[1:15])#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			} else {#
				data.subset[best.features[i],] = as.numeric(factor(data.subset[best.features[i],],labels=1:nlevels[i]))#
			}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,names(sorted.features[(index+1):(index+difference)]))#
			index = index+difference#
		}#
	}#
#
# Get rid of all of the other features#
	data.subset = data.subset[(best.features),]#
#
#	data.subset = geo_data[which(geo_data$center.language==language),c(1:10,(as.numeric(names(best.features))))]#
#
# Set the names of the columns and rows#
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(best.features,shift=10)
	heatmap(data.subset,Rowv=NA,Colv=NA,col=brewer.pal(max(nlevels),"Set1"),ColSideColors=colcolors)
#
make.feature.subset.heatmap = function(language,path) {#
# Get the subset of the features we want, relative to#
# the center language we want#
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = names(sorted.features[1:15])#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			} else {#
				data.subset[best.features[i],] = as.numeric(factor(data.subset[best.features[i],],labels=1:nlevels[i]))#
			}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,names(sorted.features[(index+1):(index+difference)]))#
			index = index+difference#
		}#
	}#
#
# Get rid of all of the other features#
	data.subset = data.subset[(best.features),]#
#
#	data.subset = geo_data[which(geo_data$center.language==language),c(1:10,(as.numeric(names(best.features))))]#
#
# Set the names of the columns and rows#
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(best.features,shift=10)#
#
# And voila!#
	pdf(path)#
	par(oma=c(2,2,2,16))#
	heatmap(data.subset,Rowv=NA,Colv=NA,col=brewer.pal(max(nlevels),"Set1"),ColSideColors=colcolors)#
	dev.off()#
}
make.feature.subset.heatmap("yim","graphs/graph2yim.pdf")
source("subs.R")#
require("RColorBrewer")#
#
geo_data = read.table("data/geo-clean-30-datapoints-r-500-fixed.csv",sep="\t",quote="\"",header=T)
width = ncol(geo_data)#
geo_data[,11:width] = sapply(geo_data[,11:width],as.numeric)#
#
# Normalize all the feature columns.#
geo_data[,11:width] = scale(geo_data[,11:width])#
#
# Change the feature column names to simple numbers. This#
# aids the lookup process later.#
names(geo_data)[11:width] = as.character((11:width))#
#
#This function sorts all the columns of the data#
# by how many NAs they have. The numbers in this#
# vector are the proportion of the column that is#
# NA.#
sorted.features = sort(colMeans(is.na(geo_data[,11:width])))#
#
# Remove the V's from the colnames#
#names(sorted.features) = substr(names(sorted.features),2,4)#
#
#
make.feature.subset.heatmap = function(language,path) {#
# Get the subset of the features we want, relative to#
# the center language we want#
	data.subset = geo_data[which(geo_data$center.language==language),]#
#
# Find the family information; this will allow us#
# to plot the right colors in the heatmap.#
	colcolors = sapply(data.subset$family,function(x) if(x=="Border") {"pink"} else if(x=="Lower Sepik-Ramu") {"brown"} else if(x == "Marind") {"yellow"} else if(x == "Sentani") {"orange"} else if (x == "Sepik") {"blue"} else if(x=="Skou") {"green"} else if(x =="Torricelli") {"purple"} else if(x == "Trans-New Guinea") {"red"} else {"white"})#
#
# Remove the non-feature columns and transpose the data#
	data.subset = t(data.subset[,11:ncol(data.subset)])#
#
# Get the 15 best-represented features, and throw out any#
# that are all the same number. Meanwhile, normalize the#
# feature values.#
	best.features = names(sorted.features[1:15])#
#
	nlevels = rep(NA,15)#
	difference = Inf#
	index = 15#
	while(difference!=0) {#
		new.best.features = best.features#
		for(i in 1:length(best.features)) {#
			feature.row = data.subset[best.features[i],]#
			nlevels[i] = length(levels(as.factor(feature.row)))#
			if(nlevels[i]==1) {#
				new.best.features = new.best.features[-i]#
			} else {#
				data.subset[best.features[i],] = as.numeric(factor(data.subset[best.features[i],],labels=1:nlevels[i]))#
			}#
		}#
#
		difference = 15-length(new.best.features)#
		if(difference > 0) {#
			best.features = c(new.best.features,names(sorted.features[(index+1):(index+difference)]))#
			index = index+difference#
		}#
	}#
#
# Get rid of all of the other features#
	data.subset = data.subset[(best.features),]#
#
#	data.subset = geo_data[which(geo_data$center.language==language),c(1:10,(as.numeric(names(best.features))))]#
#
# Set the names of the columns and rows#
	colnames(data.subset) = get.language(geo_data$wals_code[as.numeric(colnames(data.subset))])#
	rownames(data.subset) = get.feature(best.features,shift=10)#
#
# And voila!#
	pdf(path)#
	par(oma=c(2,2,2,16))#
	heatmap(data.subset,Rowv=NA,Colv=NA,col=brewer.pal(max(nlevels),"Set1"),ColSideColors=colcolors)#
	dev.off()#
}
make.feature.subset.heatmap("ala","graphs/graph2ala.pdf")#
make.feature.subset.heatmap("arp","graphs/graph2arp.pdf")#
make.feature.subset.heatmap("awt","graphs/graph2awt.pdf")#
make.feature.subset.heatmap("kew","graphs/graph2kew.pdf")#
make.feature.subset.heatmap("kob","graphs/graph2kob.pdf")#
make.feature.subset.heatmap("yim","graphs/graph2yim.pdf")
1/5+1/4
1/5+1/4 = 1/(5+4)
1/5+1/4 == 1/(5+4)
1/(5+4)
(5+4)^-1
2/(5+4)
1/5
1/4
x = c(6.7,20,33,50,2000,12465,62326,373957)
x^-1
16/7
1/6.7
sum(x^-1)
head(geo_data)
source("subs.R")
family_data = read.table("data/w_family_data.csv",sep=",",quote="\"",header=F,skip=2)#
#
width = ncol(family_data)#
names(family_data) = c("source.family","source.family","source.subfam","target.family","target.family","target.subfam","lat","long","wals_code",10:width)
family_data = family_data[which(family_data$target.family=="Niger-Congo"),]
family_data[,10:width] = sapply(family_data[,10:width],as.numeric)
family_data[,10:width] = scale(family_data[,10:width])
family_data = family_data[order(family_data$long),]
family_data = read.table("data/w_family_data.csv",sep=",",quote="\"",header=F,skip=2)#
#
width = ncol(family_data)#
names(family_data) = c("source.family","source.family","source.subfam","target.family","target.family","target.subfam","lat","long","wals_code",10:width)#
#
# Grab the Niger-Congo subfamily#
family_data = family_data[which(family_data$target.family=="Niger-Congo"),]#
#
# Let's determine which features to plot. We want to use#
# the features with the fewest most data, i.e. fewest NAs #
# in them. First, we take the relevant columns (11 and up)#
# and ensure that they are numeric.#
family_data[,10:width] = sapply(family_data[,10:width],as.numeric)#
#
# Normalize all the feature columns.#
family_data[,10:width] = scale(family_data[,10:width])#
#
# Sort the languages from west to east#
family_data = family_data[order(family_data$long),]#
#
#This function sorts all the columns of the data#
# by how many NAs they have. The numbers in this#
# vector are the proportion of the column that is#
# NA.#
sorted.features = sort(colMeans(is.na(family_data[,10:width])))#
#
# Transpose the data and remove non-feature columns#
data.subset = t(family_data[,11:ncol(data.subset)])#
#
# Make sure we have the 15-best represented features, and#
# throw out invariant features. Normalize the feature values.#
best.features = names(sorted.features[1:15])
data.subset = t(family_data[,11:ncol(family.data)])
data.subset = t(family_data[,11:ncol(family_data)])
best.features = names(sorted.features[1:15])
nlevels = rep(NA,15)#
difference = Inf#
index = 15
while(difference!=0) {#
	new.best.features = best.features#
	for(i in 1:length(best.features)) {#
		feature.row = data.subset[best.features[i],]#
		nlevels[i] = length(levels(as.factor(feature.row)))#
		if(nlevels[i]==1) {#
			new.best.features = new.best.features[-i]#
		} else {#
			data.subset[best.features[i],] = as.numeric(factor(data.subset[best.features[i],],labels=1:nlevels[i]))#
		}#
	}#
#
	difference = 15-length(new.best.features)#
	if(difference > 0) {#
		best.features = c(new.best.features,names(sorted.features[(index+1):(index+difference)]))#
		index = index+difference#
	}#
}
data.subset = data.subset[(best.features),]
colnames(data.subset) = get.language(family_data$wals_code)
rownames(data.subset) = get.feature(names(best.features),shift=0)
par(oma=c(2,2,2,15))
heatmap(data.subset,Rowv=NA,Colv=NA,scale="none")
par(oma=c(2,2,2,15))#
heatmap(data.subset,Rowv=NA,Colv=NA,scale="none",col=brewer.pal(max(nlevels),"Set1"))
head(data.subset)
rownames(data.subset)
rownames(data.subset) = get.feature(best.features,shift=0)
rownames(data.subset)
heatmap(data.subset,Rowv=NA,Colv=NA,scale="none",col=brewer.pal(max(nlevels),"Set1"))
par(oma=c(2,2,2,15))#
heatmap(data.subset,Rowv=NA,Colv=NA,scale="none",col=brewer.pal(max(nlevels),"Set1"))
pdf("graphs/graph3nigercongo.pdf")#
par(oma=c(2,2,2,15))#
heatmap(data.subset,Rowv=NA,Colv=NA,scale="none",col=brewer.pal(max(nlevels),"Set1"))#
dev.off()
?heatmap
par(oma=c(2,2,2,15))#
heatmap(data.subset,Colv=NA,scale="none",col=brewer.pal(max(nlevels),"Set1"))
par(oma=c(2,2,2,15))#
heatmap(data.subset,Colv=NA,scale="row",col=brewer.pal(max(nlevels),"Set1"))
par(oma=c(2,2,2,15))#
heatmap(data.subset,Colv=NA,scale="none",keep.dendro=F,col=brewer.pal(max(nlevels),"Set1"))
heatmap(data.subset,Colv=NA,scale="none",keep.dendro=TRUE,col=brewer.pal(max(nlevels),"Set1"))
heatmap(data.subset,Colv=NA,scale="none",keep.dendro=FALSE,col=brewer.pal(max(nlevels),"Set1"))
